<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>BOLOS TEE: bolos_crypto.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BOLOS TEE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bolos_crypto.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic Cryptographic API.  
<a href="#details">More...</a></p>

<p><a href="bolos__crypto_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9241faad72a37fea612c337a82e964aa"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a9241faad72a37fea612c337a82e964aa">bls_rng_u8</a> (void)</td></tr>
<tr class="memdesc:a9241faad72a37fea612c337a82e964aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate a random byte  <a href="#a9241faad72a37fea612c337a82e964aa">More...</a><br /></td></tr>
<tr class="separator:a9241faad72a37fea612c337a82e964aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4ef0ded59c23b0cd53552889762014"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#abe4ef0ded59c23b0cd53552889762014">bls_rng</a> (uint8_t *buffer, size_t len)</td></tr>
<tr class="memdesc:abe4ef0ded59c23b0cd53552889762014"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate a random buffer  <a href="#abe4ef0ded59c23b0cd53552889762014">More...</a><br /></td></tr>
<tr class="separator:abe4ef0ded59c23b0cd53552889762014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba01fa194837c31b70ab42fea9c4f2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#acba01fa194837c31b70ab42fea9c4f2a">bls_ripemd160_init</a> (<a class="el" href="structbls__ripemd160__s.html">bls_ripemd160_t</a> *hash)</td></tr>
<tr class="memdesc:acba01fa194837c31b70ab42fea9c4f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a ripmd160 context.  <a href="#acba01fa194837c31b70ab42fea9c4f2a">More...</a><br /></td></tr>
<tr class="separator:acba01fa194837c31b70ab42fea9c4f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e0ea766e9c8e6dc2872b6098af76c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a11e0ea766e9c8e6dc2872b6098af76c0">bls_sha1_init</a> (<a class="el" href="structbls__sha1__s.html">bls_sha1_t</a> *hash)</td></tr>
<tr class="memdesc:a11e0ea766e9c8e6dc2872b6098af76c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a sha1 context.  <a href="#a11e0ea766e9c8e6dc2872b6098af76c0">More...</a><br /></td></tr>
<tr class="separator:a11e0ea766e9c8e6dc2872b6098af76c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae228da69e446f7093ce2da0cee7d2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#acae228da69e446f7093ce2da0cee7d2a">bls_sha256_init</a> (<a class="el" href="structbls__sha256__s.html">bls_sha256_t</a> *hash)</td></tr>
<tr class="memdesc:acae228da69e446f7093ce2da0cee7d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a sha256 context.  <a href="#acae228da69e446f7093ce2da0cee7d2a">More...</a><br /></td></tr>
<tr class="separator:acae228da69e446f7093ce2da0cee7d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab139b1d61cdb1e045e7647f34808f155"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#ab139b1d61cdb1e045e7647f34808f155">bls_sha512_init</a> (<a class="el" href="structbls__sha512__s.html">bls_sha512_t</a> *hash)</td></tr>
<tr class="memdesc:ab139b1d61cdb1e045e7647f34808f155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a sha512 context.  <a href="#ab139b1d61cdb1e045e7647f34808f155">More...</a><br /></td></tr>
<tr class="separator:ab139b1d61cdb1e045e7647f34808f155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d45b76b36a4a8a8e439e06cb9bf38bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a1d45b76b36a4a8a8e439e06cb9bf38bf">bls_sha3_init</a> (<a class="el" href="structbls__sha3__s.html">bls_sha3_t</a> *hash, int size)</td></tr>
<tr class="memdesc:a1d45b76b36a4a8a8e439e06cb9bf38bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a sha3 context.  <a href="#a1d45b76b36a4a8a8e439e06cb9bf38bf">More...</a><br /></td></tr>
<tr class="separator:a1d45b76b36a4a8a8e439e06cb9bf38bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c80aaf95b68fb56584af500db272d63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a0c80aaf95b68fb56584af500db272d63">bls_keccak_init</a> (<a class="el" href="structbls__sha3__s.html">bls_sha3_t</a> *hash, int size)</td></tr>
<tr class="memdesc:a0c80aaf95b68fb56584af500db272d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a Keccak (pre-release sha3) context.  <a href="#a0c80aaf95b68fb56584af500db272d63">More...</a><br /></td></tr>
<tr class="separator:a0c80aaf95b68fb56584af500db272d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147219d68cf5eee5bade4eb3b6b4f167"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a147219d68cf5eee5bade4eb3b6b4f167">bls_hash</a> (bls_hash_t *hash, int mode, const uint8_t WIDE *in, size_t len, uint8_t *out)</td></tr>
<tr class="memdesc:a147219d68cf5eee5bade4eb3b6b4f167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add more data to hash.  <a href="#a147219d68cf5eee5bade4eb3b6b4f167">More...</a><br /></td></tr>
<tr class="separator:a147219d68cf5eee5bade4eb3b6b4f167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab671b20c3ef8ebbfcfa602e989659eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#aab671b20c3ef8ebbfcfa602e989659eb">bls_hmac_ripemd160_init</a> (<a class="el" href="structbls__hmac__ripemd160__s.html">bls_hmac_ripemd160_t</a> *hmac, const uint8_t WIDE *key, size_t key_len)</td></tr>
<tr class="memdesc:aab671b20c3ef8ebbfcfa602e989659eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a HMAC sha512 context.  <a href="#aab671b20c3ef8ebbfcfa602e989659eb">More...</a><br /></td></tr>
<tr class="separator:aab671b20c3ef8ebbfcfa602e989659eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34272ffc5ce28f25c4cfb36aefe22fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#ab34272ffc5ce28f25c4cfb36aefe22fb">bls_hmac_sha256_init</a> (<a class="el" href="structbls__hmac__sha256__s.html">bls_hmac_sha256_t</a> *hmac, const uint8_t WIDE *key, size_t key_len)</td></tr>
<tr class="memdesc:ab34272ffc5ce28f25c4cfb36aefe22fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a HMAC sha256 context.  <a href="#ab34272ffc5ce28f25c4cfb36aefe22fb">More...</a><br /></td></tr>
<tr class="separator:ab34272ffc5ce28f25c4cfb36aefe22fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d34d342ab9ce56a456cbd0587d6d02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#ad3d34d342ab9ce56a456cbd0587d6d02">bls_hmac_sha512_init</a> (<a class="el" href="structbls__hmac__sha512__s.html">bls_hmac_sha512_t</a> *hmac, const uint8_t WIDE *key, size_t key_len)</td></tr>
<tr class="memdesc:ad3d34d342ab9ce56a456cbd0587d6d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a HMAC sha512 context.  <a href="#ad3d34d342ab9ce56a456cbd0587d6d02">More...</a><br /></td></tr>
<tr class="separator:ad3d34d342ab9ce56a456cbd0587d6d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9571fc47e2e7f5632a6ceadba012ff3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a9571fc47e2e7f5632a6ceadba012ff3e">bls_hmac</a> (<a class="el" href="structbls__hmac__s.html">bls_hmac_t</a> *hmac, int mode, const uint8_t WIDE *in, size_t len, uint8_t *mac)</td></tr>
<tr class="memdesc:a9571fc47e2e7f5632a6ceadba012ff3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add more data to HMAC.  <a href="#a9571fc47e2e7f5632a6ceadba012ff3e">More...</a><br /></td></tr>
<tr class="separator:a9571fc47e2e7f5632a6ceadba012ff3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d640ec48693b729dd31573b24ea52a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a38d640ec48693b729dd31573b24ea52a">bls_pbkdf2</a> (bls_md_t hash, const <a class="el" href="structbls__area__s.html">bls_area_t</a> *password, const <a class="el" href="structbls__area__s.html">bls_area_t</a> *salt, int iterations, uint8_t *out)</td></tr>
<tr class="memdesc:a38d640ec48693b729dd31573b24ea52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stretch a password using PBKDF2.  <a href="#a38d640ec48693b729dd31573b24ea52a">More...</a><br /></td></tr>
<tr class="separator:a38d640ec48693b729dd31573b24ea52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640ecd07a8ef4c91740cee766c4609ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a640ecd07a8ef4c91740cee766c4609ac">bls_des_init_key</a> (const uint8_t WIDE *rawkey, size_t key_len, <a class="el" href="structbls__des__key__s.html">bls_des_key_t</a> *key)</td></tr>
<tr class="memdesc:a640ecd07a8ef4c91740cee766c4609ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a DES Key.  <a href="#a640ecd07a8ef4c91740cee766c4609ac">More...</a><br /></td></tr>
<tr class="separator:a640ecd07a8ef4c91740cee766c4609ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32792528e014174064b906a97d3abec6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a32792528e014174064b906a97d3abec6">bls_des</a> (<a class="el" href="structbls__des__key__s.html">bls_des_key_t</a> WIDE *key, int mode, const <a class="el" href="structbls__area__s.html">bls_area_t</a> *in, <a class="el" href="structbls__area__s.html">bls_area_t</a> *out)</td></tr>
<tr class="memdesc:a32792528e014174064b906a97d3abec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add data to a DES operation.  <a href="#a32792528e014174064b906a97d3abec6">More...</a><br /></td></tr>
<tr class="separator:a32792528e014174064b906a97d3abec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fa7ca43a3bcf196b4aae90b07b89e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#ad9fa7ca43a3bcf196b4aae90b07b89e8">bls_des_iv</a> (<a class="el" href="structbls__des__key__s.html">bls_des_key_t</a> WIDE *key, int mode, const <a class="el" href="structbls__area__s.html">bls_area_t</a> *iv, const <a class="el" href="structbls__area__s.html">bls_area_t</a> *in, <a class="el" href="structbls__area__s.html">bls_area_t</a> *out)</td></tr>
<tr class="memdesc:ad9fa7ca43a3bcf196b4aae90b07b89e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add data to a DES operation using an Initialization Vector.  <a href="#ad9fa7ca43a3bcf196b4aae90b07b89e8">More...</a><br /></td></tr>
<tr class="separator:ad9fa7ca43a3bcf196b4aae90b07b89e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d6a54dfe13393f24e113b92062b263"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a60d6a54dfe13393f24e113b92062b263">bls_aes_init_key</a> (const uint8_t WIDE *rawkey, size_t key_len, <a class="el" href="structbls__aes__key__s.html">bls_aes_key_t</a> *key)</td></tr>
<tr class="memdesc:a60d6a54dfe13393f24e113b92062b263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an AES Key.  <a href="#a60d6a54dfe13393f24e113b92062b263">More...</a><br /></td></tr>
<tr class="separator:a60d6a54dfe13393f24e113b92062b263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619568b15c968ebea296458bc50f79a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a619568b15c968ebea296458bc50f79a7">bls_aes</a> (<a class="el" href="structbls__aes__key__s.html">bls_aes_key_t</a> WIDE *key, int mode, const <a class="el" href="structbls__area__s.html">bls_area_t</a> *in, <a class="el" href="structbls__area__s.html">bls_area_t</a> *out)</td></tr>
<tr class="memdesc:a619568b15c968ebea296458bc50f79a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add data to an AES operation.  <a href="#a619568b15c968ebea296458bc50f79a7">More...</a><br /></td></tr>
<tr class="separator:a619568b15c968ebea296458bc50f79a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3770b3210bd228a2c123f0b124a1f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#aad3770b3210bd228a2c123f0b124a1f6">bls_aes_iv</a> (<a class="el" href="structbls__aes__key__s.html">bls_aes_key_t</a> WIDE *key, int mode, const <a class="el" href="structbls__area__s.html">bls_area_t</a> *iv, const <a class="el" href="structbls__area__s.html">bls_area_t</a> *in, <a class="el" href="structbls__area__s.html">bls_area_t</a> *out)</td></tr>
<tr class="memdesc:aad3770b3210bd228a2c123f0b124a1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add data to an AES operation using an Initialization Vector.  <a href="#aad3770b3210bd228a2c123f0b124a1f6">More...</a><br /></td></tr>
<tr class="separator:aad3770b3210bd228a2c123f0b124a1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8372582f8e5b9d9a9131665c8a8569d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a8372582f8e5b9d9a9131665c8a8569d5">bls_aes_iv_gcm</a> (<a class="el" href="structbls__aes__key__s.html">bls_aes_key_t</a> WIDE *key, int mode, const <a class="el" href="structbls__area__s.html">bls_area_t</a> *in, const <a class="el" href="structbls__area__s.html">bls_area_t</a> *iv, const <a class="el" href="structbls__area__s.html">bls_area_t</a> WIDE *aadTag, <a class="el" href="structbls__area__s.html">bls_area_t</a> *out)</td></tr>
<tr class="memdesc:a8372582f8e5b9d9a9131665c8a8569d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add data to an AES GCM operation.  <a href="#a8372582f8e5b9d9a9131665c8a8569d5">More...</a><br /></td></tr>
<tr class="separator:a8372582f8e5b9d9a9131665c8a8569d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fa77fc850d8e44a085002ce63a7a4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a28fa77fc850d8e44a085002ce63a7a4a">bls_rsa_init_public_key</a> (const <a class="el" href="structbls__rsa__keypair__data__s.html">bls_rsa_keypair_data_t</a> WIDE *keyData, <a class="el" href="structbls__rsa__abstract__public__key__s.html">bls_rsa_abstract_public_key_t</a> *key)</td></tr>
<tr class="memdesc:a28fa77fc850d8e44a085002ce63a7a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a public RSA Key.  <a href="#a28fa77fc850d8e44a085002ce63a7a4a">More...</a><br /></td></tr>
<tr class="separator:a28fa77fc850d8e44a085002ce63a7a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df659201c372c4bb7d3df7d5fbc202a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a8df659201c372c4bb7d3df7d5fbc202a">bls_rsa_init_private_key</a> (const <a class="el" href="structbls__rsa__keypair__data__s.html">bls_rsa_keypair_data_t</a> WIDE *keyData, <a class="el" href="structbls__rsa__abstract__private__key__s.html">bls_rsa_abstract_private_key_t</a> *key)</td></tr>
<tr class="memdesc:a8df659201c372c4bb7d3df7d5fbc202a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a private RSA Key.  <a href="#a8df659201c372c4bb7d3df7d5fbc202a">More...</a><br /></td></tr>
<tr class="separator:a8df659201c372c4bb7d3df7d5fbc202a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde738e372aa1e0bf6d157c4f0e292a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#acde738e372aa1e0bf6d157c4f0e292a5">bls_rsa_init_private_key_crt</a> (const <a class="el" href="structbls__rsa__crt__s.html">bls_rsa_crt_t</a> WIDE *crtParameters, <a class="el" href="structbls__rsa__abstract__private__key__s.html">bls_rsa_abstract_private_key_t</a> *key)</td></tr>
<tr class="memdesc:acde738e372aa1e0bf6d157c4f0e292a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a private RSA Key with CRT parameters.  <a href="#acde738e372aa1e0bf6d157c4f0e292a5">More...</a><br /></td></tr>
<tr class="separator:acde738e372aa1e0bf6d157c4f0e292a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a39bcc62951fe07ac5ddcb38f15758a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a6a39bcc62951fe07ac5ddcb38f15758a">bls_rsa_generate_keypair</a> (int modulus_len, <a class="el" href="structbls__rsa__abstract__private__key__s.html">bls_rsa_abstract_private_key_t</a> *privateKey, <a class="el" href="structbls__rsa__abstract__public__key__s.html">bls_rsa_abstract_public_key_t</a> *publicKey, <a class="el" href="structbls__rsa__keypair__data__s.html">bls_rsa_keypair_data_t</a> *generatedKeypairInfo)</td></tr>
<tr class="memdesc:a6a39bcc62951fe07ac5ddcb38f15758a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a RSA keypair.  <a href="#a6a39bcc62951fe07ac5ddcb38f15758a">More...</a><br /></td></tr>
<tr class="separator:a6a39bcc62951fe07ac5ddcb38f15758a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc949256aec16e18bb291e2668d8f693"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#acc949256aec16e18bb291e2668d8f693">bls_rsa_get_public_key_data</a> (<a class="el" href="structbls__rsa__abstract__public__key__s.html">bls_rsa_abstract_public_key_t</a> *publicKey, <a class="el" href="structbls__rsa__keypair__data__s.html">bls_rsa_keypair_data_t</a> *keyInfo)</td></tr>
<tr class="memdesc:acc949256aec16e18bb291e2668d8f693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a RSA public key information.  <a href="#acc949256aec16e18bb291e2668d8f693">More...</a><br /></td></tr>
<tr class="separator:acc949256aec16e18bb291e2668d8f693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9dc43b301fc2f630af838d5164075bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#ad9dc43b301fc2f630af838d5164075bb">bls_rsa_pub</a> (<a class="el" href="structbls__rsa__abstract__public__key__s.html">bls_rsa_abstract_public_key_t</a> WIDE *key, int mode, bls_md_t hashID, const <a class="el" href="structbls__area__s.html">bls_area_t</a> *src, const <a class="el" href="structbls__area__s.html">bls_area_t</a> *dest)</td></tr>
<tr class="memdesc:ad9dc43b301fc2f630af838d5164075bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a RSA public operation.  <a href="#ad9dc43b301fc2f630af838d5164075bb">More...</a><br /></td></tr>
<tr class="separator:ad9dc43b301fc2f630af838d5164075bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62e06cad62c7a39b6a62015f3252ecd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#ac62e06cad62c7a39b6a62015f3252ecd">bls_rsa_priv</a> (<a class="el" href="structbls__rsa__abstract__private__key__s.html">bls_rsa_abstract_private_key_t</a> WIDE *key, int mode, bls_md_t hashID, const <a class="el" href="structbls__area__s.html">bls_area_t</a> *src, const <a class="el" href="structbls__area__s.html">bls_area_t</a> *dest)</td></tr>
<tr class="memdesc:ac62e06cad62c7a39b6a62015f3252ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a RSA private operation.  <a href="#ac62e06cad62c7a39b6a62015f3252ecd">More...</a><br /></td></tr>
<tr class="separator:ac62e06cad62c7a39b6a62015f3252ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037c223bf5a33ae5f4c0c9b9e8a6ef82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbls__curve__domain__s.html">bls_curve_domain_t</a> WIDE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a037c223bf5a33ae5f4c0c9b9e8a6ef82">bls_ecfp_get_domain</a> (bls_curve_t curve)</td></tr>
<tr class="memdesc:a037c223bf5a33ae5f4c0c9b9e8a6ef82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the domain of the curve.  <a href="#a037c223bf5a33ae5f4c0c9b9e8a6ef82">More...</a><br /></td></tr>
<tr class="separator:a037c223bf5a33ae5f4c0c9b9e8a6ef82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20da77005d8a6d8b41f56cbfaa9e7905"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a20da77005d8a6d8b41f56cbfaa9e7905">bls_ecfp_is_valid_point</a> (const <a class="el" href="structbls__curve__domain__s.html">bls_curve_domain_t</a> WIDE *domain, const uint8_t WIDE *point)</td></tr>
<tr class="memdesc:a20da77005d8a6d8b41f56cbfaa9e7905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that a given point is really on the specified curve.  <a href="#a20da77005d8a6d8b41f56cbfaa9e7905">More...</a><br /></td></tr>
<tr class="separator:a20da77005d8a6d8b41f56cbfaa9e7905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7c50bcb08f7bc0af8dd81e50690935"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a1c7c50bcb08f7bc0af8dd81e50690935">bls_ecfp_add_point</a> (const <a class="el" href="structbls__curve__domain__s.html">bls_curve_domain_t</a> WIDE *domain, uint8_t *R, const uint8_t WIDE *P, const uint8_t WIDE *Q)</td></tr>
<tr class="memdesc:a1c7c50bcb08f7bc0af8dd81e50690935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two affine point.  <a href="#a1c7c50bcb08f7bc0af8dd81e50690935">More...</a><br /></td></tr>
<tr class="separator:a1c7c50bcb08f7bc0af8dd81e50690935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579907be6bb41ed100e1c3d1e00c5c1d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a579907be6bb41ed100e1c3d1e00c5c1d">bls_ecdsa_init_public_key</a> (bls_curve_t curve, const uint8_t WIDE *rawkey, size_t key_len, <a class="el" href="structbls__ecfp__public__key__s.html">bls_ecfp_public_key_t</a> *key)</td></tr>
<tr class="memdesc:a579907be6bb41ed100e1c3d1e00c5c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a public ECFP Key.  <a href="#a579907be6bb41ed100e1c3d1e00c5c1d">More...</a><br /></td></tr>
<tr class="separator:a579907be6bb41ed100e1c3d1e00c5c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c59edcec3c6bd79e05f5da4c42feed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#ac5c59edcec3c6bd79e05f5da4c42feed">bls_ecdsa_init_private_key</a> (bls_curve_t curve, const uint8_t WIDE *rawkey, size_t key_len, <a class="el" href="structbls__ecfp__private__key__s.html">bls_ecfp_private_key_t</a> *key)</td></tr>
<tr class="memdesc:ac5c59edcec3c6bd79e05f5da4c42feed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a private ECFP Key.  <a href="#ac5c59edcec3c6bd79e05f5da4c42feed">More...</a><br /></td></tr>
<tr class="separator:ac5c59edcec3c6bd79e05f5da4c42feed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376d317eb97e1965c71b05dd9115ae83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a376d317eb97e1965c71b05dd9115ae83">bls_ecfp_generate_pair</a> (bls_curve_t curve, <a class="el" href="structbls__ecfp__public__key__s.html">bls_ecfp_public_key_t</a> *public_key, <a class="el" href="structbls__ecfp__private__key__s.html">bls_ecfp_private_key_t</a> *private_key, uint8_t *d)</td></tr>
<tr class="memdesc:a376d317eb97e1965c71b05dd9115ae83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a ecfp key pair.  <a href="#a376d317eb97e1965c71b05dd9115ae83">More...</a><br /></td></tr>
<tr class="separator:a376d317eb97e1965c71b05dd9115ae83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af426cf665f80dd28ebc4b2c9d089e033"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#af426cf665f80dd28ebc4b2c9d089e033">bls_ecfp_get_public_component</a> (const <a class="el" href="structbls__ecfp__public__key__s.html">bls_ecfp_public_key_t</a> *public_key, uint8_t *W)</td></tr>
<tr class="memdesc:af426cf665f80dd28ebc4b2c9d089e033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the uncompressed point of a public ECFP Key.  <a href="#af426cf665f80dd28ebc4b2c9d089e033">More...</a><br /></td></tr>
<tr class="separator:af426cf665f80dd28ebc4b2c9d089e033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7b31b36b3182dab513fbbec43616ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a4b7b31b36b3182dab513fbbec43616ea">bls_ecdsa_sign</a> (<a class="el" href="structbls__ecfp__private__key__s.html">bls_ecfp_private_key_t</a> WIDE *key, int mode, bls_md_t hashID, const uint8_t WIDE *hash, size_t hash_len, uint8_t *sig)</td></tr>
<tr class="memdesc:a4b7b31b36b3182dab513fbbec43616ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign a hash message according to ECDSA scheme.  <a href="#a4b7b31b36b3182dab513fbbec43616ea">More...</a><br /></td></tr>
<tr class="separator:a4b7b31b36b3182dab513fbbec43616ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afccee835a6363a33c79d6026e07ce1c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#afccee835a6363a33c79d6026e07ce1c6">bls_ecdsa_verify</a> (<a class="el" href="structbls__ecfp__public__key__s.html">bls_ecfp_public_key_t</a> WIDE *key, int mode, bls_md_t hashID, const uint8_t WIDE *hash, size_t hash_len, uint8_t *sig)</td></tr>
<tr class="memdesc:afccee835a6363a33c79d6026e07ce1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify a hash message signature according to ECDSA scheme.  <a href="#afccee835a6363a33c79d6026e07ce1c6">More...</a><br /></td></tr>
<tr class="separator:afccee835a6363a33c79d6026e07ce1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0650665b77deb5b79b48626649b33f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#ab0650665b77deb5b79b48626649b33f5">bls_schnorr_sign</a> (<a class="el" href="structbls__ecfp__private__key__s.html">bls_ecfp_private_key_t</a> WIDE *key, int mode, bls_md_t hashID, const uint8_t WIDE *hash, size_t hash_len, uint8_t *sig)</td></tr>
<tr class="memdesc:ab0650665b77deb5b79b48626649b33f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign a hash message according to Schnorr scheme.  <a href="#ab0650665b77deb5b79b48626649b33f5">More...</a><br /></td></tr>
<tr class="separator:ab0650665b77deb5b79b48626649b33f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1509989f1a3110ec245bc3cea7d0a9fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a1509989f1a3110ec245bc3cea7d0a9fc">bls_schnorr_verify</a> (<a class="el" href="structbls__ecfp__public__key__s.html">bls_ecfp_public_key_t</a> WIDE *key, int mode, bls_md_t hashID, const uint8_t WIDE *hash, size_t hash_len, uint8_t *sig)</td></tr>
<tr class="memdesc:a1509989f1a3110ec245bc3cea7d0a9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify a hash message signature according to Schnorr scheme.  <a href="#a1509989f1a3110ec245bc3cea7d0a9fc">More...</a><br /></td></tr>
<tr class="separator:a1509989f1a3110ec245bc3cea7d0a9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706c88d2cd272faadff6779cad55567e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a706c88d2cd272faadff6779cad55567e">bls_ecdh</a> (<a class="el" href="structbls__ecfp__private__key__s.html">bls_ecfp_private_key_t</a> WIDE *key, int mode, const uint8_t WIDE *public_point, uint8_t *secret)</td></tr>
<tr class="memdesc:a706c88d2cd272faadff6779cad55567e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a shared secret according to ECDH specifiaction.  <a href="#a706c88d2cd272faadff6779cad55567e">More...</a><br /></td></tr>
<tr class="separator:a706c88d2cd272faadff6779cad55567e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26decc15883c5b7554635350c7221f27"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a26decc15883c5b7554635350c7221f27">bls_crc16</a> (const void WIDE *buffer, size_t len)</td></tr>
<tr class="memdesc:a26decc15883c5b7554635350c7221f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a 16 bits checksum value.  <a href="#a26decc15883c5b7554635350c7221f27">More...</a><br /></td></tr>
<tr class="separator:a26decc15883c5b7554635350c7221f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa86941c76ff857ec1e23319e632f02"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a8aa86941c76ff857ec1e23319e632f02">bls_crc16_update</a> (unsigned short crc, const void WIDE *buffer, size_t len)</td></tr>
<tr class="memdesc:a8aa86941c76ff857ec1e23319e632f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a 16 bits checksum value.  <a href="#a8aa86941c76ff857ec1e23319e632f02">More...</a><br /></td></tr>
<tr class="separator:a8aa86941c76ff857ec1e23319e632f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c0b25f3ac0307842bbdc9322d223c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#af7c0b25f3ac0307842bbdc9322d223c0">bls_math_addm</a> (uint8_t *r, const uint8_t WIDE *a, const uint8_t WIDE *b, const uint8_t WIDE *m, size_t len)</td></tr>
<tr class="memdesc:af7c0b25f3ac0307842bbdc9322d223c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modular addition of tow big integer of the size: r = a+b mod m.  <a href="#af7c0b25f3ac0307842bbdc9322d223c0">More...</a><br /></td></tr>
<tr class="separator:af7c0b25f3ac0307842bbdc9322d223c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4762eaf9596091725da4a10c29a9a11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#aa4762eaf9596091725da4a10c29a9a11">bls_math_cmp</a> (const uint8_t WIDE *a, const uint8_t WIDE *b, size_t len)</td></tr>
<tr class="memdesc:aa4762eaf9596091725da4a10c29a9a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare to unsigned long big-endian integer.  <a href="#aa4762eaf9596091725da4a10c29a9a11">More...</a><br /></td></tr>
<tr class="separator:aa4762eaf9596091725da4a10c29a9a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b79f52eef59c6677690dc81151aeeb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a10b79f52eef59c6677690dc81151aeeb">bls_math_is_zero</a> (const uint8_t WIDE *a, size_t len)</td></tr>
<tr class="memdesc:a10b79f52eef59c6677690dc81151aeeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare to unsigned long big-endian integer to zero.  <a href="#a10b79f52eef59c6677690dc81151aeeb">More...</a><br /></td></tr>
<tr class="separator:a10b79f52eef59c6677690dc81151aeeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a451e351994ca9009b5409b1d03af28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bolos__crypto_8h.html#a9a451e351994ca9009b5409b1d03af28">bls_math_modm</a> (uint8_t *v, size_t len_v, const uint8_t WIDE *m, size_t len_m)</td></tr>
<tr class="memdesc:a9a451e351994ca9009b5409b1d03af28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce in place (left zero padded) the given value : v = v mod m.  <a href="#a9a451e351994ca9009b5409b1d03af28">More...</a><br /></td></tr>
<tr class="separator:a9a451e351994ca9009b5409b1d03af28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generic Cryptographic API. </p>
<dl class="section author"><dt>Author</dt><dd>Ledger Firmware Team <a href="#" onclick="location.href='mai'+'lto:'+'hel'+'lo'+'@le'+'dg'+'er.'+'fr'; return false;">hello<span style="display: none;">.nosp@m.</span>@led<span style="display: none;">.nosp@m.</span>ger.f<span style="display: none;">.nosp@m.</span>r</a> </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>29th of February 2016</dd></dl>
<p>Perform general purpose cryptographic operations</p>
<p>In this release, the API doesn't implement exceptions </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a619568b15c968ebea296458bc50f79a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_aes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__aes__key__s.html">bls_aes_key_t</a> WIDE *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbls__area__s.html">bls_area_t</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbls__area__s.html">bls_area_t</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add data to an AES operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>A aes key fully inited with 'bls_aes_init_key'</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>16bits crypto mode flags. See above. Supported flags:<ul>
<li>BLS_LAST</li>
<li>BLS_ENCRYPT</li>
<li>BLS_DECRYPT</li>
<li>BLS_SIGN</li>
<li>BLS_VERIFY</li>
<li>BLS_PAD_NONE</li>
<li>BLS_PAD_ISO9797M1</li>
<li>BLS_PAD_ISO9797M2</li>
<li>BLS_CHAIN_ECB</li>
<li>BLS_CHAIN_CBC</li>
<li>BLS_AES_PAD_CTR</li>
<li>BLS_AES_PAD_CFB</li>
<li>BLS_AES_PAD_OFB</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Input data to encrypt/decrypt and associated length If BLS_LAST is set, padding is automtically done according to 'mode'. Else 'len' shall be a multiple of AES_BLOCK_SIZE.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Either:<ul>
<li>encrypted/decrypted ouput data</li>
<li>produced signature</li>
<li>signature to check 'out' buffer length is implicit, no check is done</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>In case of ENCRYPT, DECRYPT or SIGN mode: output length data</li>
<li>In case of VERIFY mode: 0 if signature is false, AES_BLOCK_SIZE if signature is correct</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60d6a54dfe13393f24e113b92062b263"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_aes_init_key </td>
          <td>(</td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>rawkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbls__aes__key__s.html">bls_aes_key_t</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an AES Key. </p>
<p>Once initialized, the key may be stored in non-volatile memory an reused 'as-is' for any AES processing</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawkey</td><td>raw key value</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_len</td><td>key bytes length: 16 or 32</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key</td><td>AES key to init</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>ready to use key to init</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error </dd></dl>

</div>
</div>
<a class="anchor" id="aad3770b3210bd228a2c123f0b124a1f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_aes_iv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__aes__key__s.html">bls_aes_key_t</a> WIDE *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbls__area__s.html">bls_area_t</a> *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbls__area__s.html">bls_area_t</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbls__area__s.html">bls_area_t</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add data to an AES operation using an Initialization Vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>A aes key fully inited with 'bls_aes_init_key'</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>16bits crypto mode flags. See above. Supported flags:<ul>
<li>BLS_LAST</li>
<li>BLS_ENCRYPT</li>
<li>BLS_DECRYPT</li>
<li>BLS_SIGN</li>
<li>BLS_VERIFY</li>
<li>BLS_PAD_NONE</li>
<li>BLS_PAD_ISO9797M1</li>
<li>BLS_PAD_ISO9797M2</li>
<li>BLS_CHAIN_ECB</li>
<li>BLS_CHAIN_CBC</li>
<li>BLS_AES_PAD_CTR</li>
<li>BLS_AES_PAD_CFB</li>
<li>BLS_AES_PAD_OFB</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iv</td><td>Initialization Vector and associated length Only meaningful for the first block of a BLS_CHAIN_CBC, BLS_AES_PAD_CTR, BLS_AES_PAD_CFB, BLS_AES_PAD_OFB chaining. 'len' shall be a multiple of DES_BLOCK_SIZE.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Input data to encrypt/decrypt and associated length If BLS_LAST is set, padding is automtically done according to 'mode'. Else 'len' shall be a multiple of AES_BLOCK_SIZE.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Either:<ul>
<li>encrypted/decrypted ouput data</li>
<li>produced signature</li>
<li>signature to check 'out' buffer length is implicit, no check is done</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>In case of ENCRYPT, DECRYPT or SIGN mode: output length data</li>
<li>In case of VERIFY mode: 0 if signature is false, AES_BLOCK_SIZE if signature is correct</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8372582f8e5b9d9a9131665c8a8569d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_aes_iv_gcm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__aes__key__s.html">bls_aes_key_t</a> WIDE *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbls__area__s.html">bls_area_t</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbls__area__s.html">bls_area_t</a> *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbls__area__s.html">bls_area_t</a> WIDE *&#160;</td>
          <td class="paramname"><em>aadTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbls__area__s.html">bls_area_t</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add data to an AES GCM operation. </p>
<dl class="section warning"><dt>Warning</dt><dd>THIS METHOD IS NOT SUPPORTED IN THE CURRENT RELEASE</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>A aes key fully inited with 'bls_aes_init_key'</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>16bits crypto mode flags. See above. Supported flags:<ul>
<li>BLS_LAST</li>
<li>BLS_ENCRYPT</li>
<li>BLS_DECRYPT</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Input data to encrypt/decrypt and associated length If BLS_LAST is set, padding is automtically done according to 'mode'. Else 'len' shall be a multiple of AES_BLOCK_SIZE.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iv</td><td>Initialization Vector and associated length 'len' shall be a multiple of DES_BLOCK_SIZE.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">aadTag</td><td><ul>
<li>In case of ENCRYPT mode : AAD in, tag out</li>
<li>In case of DECRYPT mode : tag in</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Either:<ul>
<li>encrypted/decrypted ouput data 'out' buffer length is implicit, no check is done</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>In case of ENCRYPT, DECRYPT : output length data</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26decc15883c5b7554635350c7221f27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t bls_crc16 </td>
          <td>(</td>
          <td class="paramtype">const void WIDE *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a 16 bits checksum value. </p>
<p>The 16 bits value is computed according to the CRC16 CCITT definition.</p>
<dl class="section warning"><dt>Warning</dt><dd>THIS METHOD IS NOT SUPPORTED IN THE CURRENT RELEASE</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The buffer to compute the crc over.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Bytes</td><td>Length of the 'buffer'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CRC value </dd></dl>

</div>
</div>
<a class="anchor" id="a8aa86941c76ff857ec1e23319e632f02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t bls_crc16_update </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>crc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void WIDE *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a 16 bits checksum value. </p>
<p>The 16 bits value is computed according to the CRC16 CCITT definition.</p>
<dl class="section warning"><dt>Warning</dt><dd>THIS METHOD IS NOT SUPPORTED IN THE CURRENT RELEASE</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">crc</td><td>Initial CRC value</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The buffer to compute the crc over.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Bytes</td><td>Length of the 'buffer'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CRC value </dd></dl>

</div>
</div>
<a class="anchor" id="a32792528e014174064b906a97d3abec6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_des </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__des__key__s.html">bls_des_key_t</a> WIDE *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbls__area__s.html">bls_area_t</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbls__area__s.html">bls_area_t</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add data to a DES operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>A des key fully inited with 'bls_des_init_key'</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>16bits crypto mode flags. See above. Supported flags:<ul>
<li>BLS_LAST</li>
<li>BLS_ENCRYPT</li>
<li>BLS_DECRYPT</li>
<li>BLS_SIGN</li>
<li>BLS_VERIFY</li>
<li>BLS_PAD_NONE</li>
<li>BLS_PAD_ISO9797M1</li>
<li>BLS_PAD_ISO9797M2</li>
<li>BLS_CHAIN_ECB</li>
<li>BLS_CHAIN_CBC</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Input data to encrypt/decrypt and associated length If BLS_LAST is set, padding is automatically done according to 'mode'. Else 'len' shall be a multiple of DES_BLOCK_SIZE.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Either:<ul>
<li>encrypted/decrypted ouput data</li>
<li>produced signature</li>
<li>signature to check</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>In case of ENCRYPT, DECRYPT or SIGN mode: output length data</li>
<li>In case of VERIFY mode: 0 if signature is false, DES_BLOCK_SIZE if signature is correct</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a640ecd07a8ef4c91740cee766c4609ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_des_init_key </td>
          <td>(</td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>rawkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbls__des__key__s.html">bls_des_key_t</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a DES Key. </p>
<p>Once initialized, the key may be stored in non-volatile memory an reused 'as-is' for any DES processing</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawkey</td><td>raw key value</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_len</td><td>key bytes length: 8,16 or 24</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key</td><td>DES key to init</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>ready to use key to init</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error </dd></dl>

</div>
</div>
<a class="anchor" id="ad9fa7ca43a3bcf196b4aae90b07b89e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_des_iv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__des__key__s.html">bls_des_key_t</a> WIDE *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbls__area__s.html">bls_area_t</a> *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbls__area__s.html">bls_area_t</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbls__area__s.html">bls_area_t</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add data to a DES operation using an Initialization Vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>A des key fully inited with 'bls_des_init_key'</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>16bits crypto mode flags. See above. Supported flags:<ul>
<li>BLS_LAST</li>
<li>BLS_ENCRYPT</li>
<li>BLS_DECRYPT</li>
<li>BLS_SIGN</li>
<li>BLS_VERIFY</li>
<li>BLS_PAD_NONE</li>
<li>BLS_PAD_ISO9797M1</li>
<li>BLS_PAD_ISO9797M2</li>
<li>BLS_CHAIN_ECB</li>
<li>BLS_CHAIN_CBC</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iv</td><td>Initialization Vector and associated length Only meaningful for the first block of a BLS_CHAIN_CBC chaining. 'len' shall be a multiple of DES_BLOCK_SIZE.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Input data to encrypt/decrypt and associated length If BLS_LAST is set, padding is automatically done according to 'mode'. Else 'len' shall be a multiple of DES_BLOCK_SIZE.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Either:<ul>
<li>encrypted/decrypted ouput data</li>
<li>produced signature</li>
<li>signature to check</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>In case of ENCRYPT, DECRYPT or SIGN mode: output length data</li>
<li>In case of VERIFY mode: 0 if signature is false, DES_BLOCK_SIZE if signature is correct</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a706c88d2cd272faadff6779cad55567e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_ecdh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__ecfp__private__key__s.html">bls_ecfp_private_key_t</a> WIDE *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>public_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>secret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a shared secret according to ECDH specifiaction. </p>
<p>Depending on the mode, the shared secret is either the full point, a hash of the x coordinate or only the x coordinate</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>A private ecfp key fully inited with 'bls_ecdsa_init_private_key'</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>16bits crypto mode flags. See above. Supported flags:<ul>
<li>BLS_ECDH_POINT</li>
<li>BLS_ECDH_X</li>
<li>BLS_ECDH_HASHED</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_point</td><td>Other party public point encoded as: 04 x y, where x and y are encoded as big endian raw value and have bits length equals to the curve size.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">secret</td><td>Generated shared secret.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of secret</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5c59edcec3c6bd79e05f5da4c42feed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_ecdsa_init_private_key </td>
          <td>(</td>
          <td class="paramtype">bls_curve_t&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>rawkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbls__ecfp__private__key__s.html">bls_ecfp_private_key_t</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a private ECFP Key. </p>
<p>Once initialized, the key may be stored in non-volatile memory and reused 'as-is' for any ECDSA processing Passing NULL as raw key initializes the key without value. The key may be used as parameter for bls_ecfp_generate_pair.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curve</td><td>The curve domain parameters to work with.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rawkey</td><td>Raw key value or NULL. The value shall be the private key big endian raw value.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_len</td><td>Key bytes length</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key</td><td>Private ecfp key to init.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a579907be6bb41ed100e1c3d1e00c5c1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_ecdsa_init_public_key </td>
          <td>(</td>
          <td class="paramtype">bls_curve_t&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>rawkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbls__ecfp__public__key__s.html">bls_ecfp_public_key_t</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a public ECFP Key. </p>
<p>Once initialized, the key may be stored in non-volatile memory an reused 'as-is' for any ECDSA processing Passing NULL as raw key initializes the key without value. The key may be used as parameter for bls_ecfp_generate_pair.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curve</td><td>The curve domain parameters to work with.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rawkey</td><td>Raw key value or NULL. The value shall be the public point encoded as: 04 x y, where x and y are encoded as big endian raw value and have bits length equals to the curve size.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_len</td><td>Key bytes length</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key</td><td>Public ecfp key to init.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b7b31b36b3182dab513fbbec43616ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_ecdsa_sign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__ecfp__private__key__s.html">bls_ecfp_private_key_t</a> WIDE *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bls_md_t&#160;</td>
          <td class="paramname"><em>hashID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hash_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sign a hash message according to ECDSA scheme. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>A private ecfp key fully inited with 'bls_ecdsa_init_private_key'</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>16bits crypto mode flags. See above. Supported flags:<ul>
<li>BLS_LAST</li>
<li>BLS_RND_TRNG</li>
<li>BLS_RND_RFC6979</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hashID</td><td>Hash to use for nonce generation when using BLS_RND_RFC6979 (shall be BLS_SHA256)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>Input data to sign. The data should be the hash of the original message. The data length must be lesser than the curve size.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_len</td><td>Length of the hash</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sig</td><td>ECDSA signature encoded as TLV: 30 L 02 Lr r 02 Ls s</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Full length of signature</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afccee835a6363a33c79d6026e07ce1c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_ecdsa_verify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__ecfp__public__key__s.html">bls_ecfp_public_key_t</a> WIDE *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bls_md_t&#160;</td>
          <td class="paramname"><em>hashID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hash_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify a hash message signature according to ECDSA scheme. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>A public ecfp key fully inited with 'bls_ecdsa_init_public_key'</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>16bits crypto mode flags. See above. Supported flags:<ul>
<li>BLS_LAST</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hashID</td><td>Ignored</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>Signed input data to verify the signature. The data should be the hash of the original message. The data length must be lesser than the curve size.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_len</td><td>Length of the hash</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>ECDSA signature to verify encoded as TLV: 30 L 02 Lr r 02 Ls s</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if signature is verified 0 is signarure is not verified</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c7c50bcb08f7bc0af8dd81e50690935"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_ecfp_add_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbls__curve__domain__s.html">bls_curve_domain_t</a> WIDE *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add two affine point. </p>
<dl class="section warning"><dt>Warning</dt><dd>THIS METHOD IS NOT SUPPORTED IN THE CURRENT RELEASE</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>The curve domain parameters to work with.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>P+Q encoded as: 04 x y, where x and y are encoded as big endian raw value and have bits length equals to the curve size.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>First point to add * The value shall be a point encoded as: 04 x y, where x and y are encoded as big endian raw value and have bits length equals to the curve size.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td>Second point to add</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_point</td><td>The point to test encoded as: 04 x y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>R encoding length, if add success -1 if failed</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a376d317eb97e1965c71b05dd9115ae83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_ecfp_generate_pair </td>
          <td>(</td>
          <td class="paramtype">bls_curve_t&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbls__ecfp__public__key__s.html">bls_ecfp_public_key_t</a> *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbls__ecfp__private__key__s.html">bls_ecfp_private_key_t</a> *&#160;</td>
          <td class="paramname"><em>private_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a ecfp key pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curve</td><td>The curve domain parameters to work with.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">public_key</td><td>A public ecfp key to generate.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">private_key</td><td>A private ecfp key to initialize.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>If set to non NULL, return the generated private key value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a037c223bf5a33ae5f4c0c9b9e8a6ef82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbls__curve__domain__s.html">bls_curve_domain_t</a> WIDE* bls_ecfp_get_domain </td>
          <td>(</td>
          <td class="paramtype">bls_curve_t&#160;</td>
          <td class="paramname"><em>curve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the domain of the curve. </p>
<dl class="section warning"><dt>Warning</dt><dd>THIS METHOD IS NOT SUPPORTED IN THE CURRENT RELEASE</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">curve</td><td>The curve reference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The curve domain</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af426cf665f80dd28ebc4b2c9d089e033"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_ecfp_get_public_component </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbls__ecfp__public__key__s.html">bls_ecfp_public_key_t</a> *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the uncompressed point of a public ECFP Key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">public_key</td><td>A public ecfp key</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>Buffer to store uncompressed point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20da77005d8a6d8b41f56cbfaa9e7905"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_ecfp_is_valid_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbls__curve__domain__s.html">bls_curve_domain_t</a> WIDE *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify that a given point is really on the specified curve. </p>
<dl class="section warning"><dt>Warning</dt><dd>THIS METHOD IS NOT SUPPORTED IN THE CURRENT RELEASE</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain</td><td>The curve domain parameters to work with.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>The point to test encoded as: 04 x y</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if point is on the curve 0 if point is not on the curve -1 if undefined (function not implemented)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a147219d68cf5eee5bade4eb3b6b4f167"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_hash </td>
          <td>(</td>
          <td class="paramtype">bls_hash_t *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add more data to hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hash</td><td>Hash context The hash context pointer shall point to either a bls_ripemd160_t, either a bls_sha256_t or bls_sha512_t . The hash context shall be inited with 'bls_xxx_init' The hash context shall be in RAM The function should be called with a nice cast.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>16bits flags. See Above If BLS_LAST is set, context is automatically re-inited. Supported flags:<ul>
<li>BLS_LAST</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Input data to add to current hash</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of input to data.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Either:<ul>
<li>NULL (ignored) if BLS_LAST is NOT set</li>
<li>produced hash if BLS_LAST is set 'out' length is implicit, no check is done</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, not finished. Hash size if success, finished. 0 if error </dd></dl>

</div>
</div>
<a class="anchor" id="a9571fc47e2e7f5632a6ceadba012ff3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_hmac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__hmac__s.html">bls_hmac_t</a> *&#160;</td>
          <td class="paramname"><em>hmac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add more data to HMAC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hmac</td><td>Hmac context The hmac context pointer shall point to either a bls_ripemd160_t, either a bls_sha256_t or bls_sha512_t . The hmac context shall be inited with 'bls_xxx_init' The hmac context shall be in RAM The function should be called with a nice cast.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>16bits flags. See Above If BLS_LAST is set and BLS_DISCARD is not set, context is automatically re-inited. Supported flags:<ul>
<li>BLS_LAST</li>
<li>BLS_DISCARD</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Input data to add to current hmac</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of input to data.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mac</td><td>Either:<ul>
<li>NULL (ignored) if BLS_LAST is NOT set</li>
<li>produced hmac if BLS_LAST is set 'out' length is implicit, no check is done</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, not finished. Hmac size if success, finished. 0 if error </dd></dl>

</div>
</div>
<a class="anchor" id="aab671b20c3ef8ebbfcfa602e989659eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_hmac_ripemd160_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__hmac__ripemd160__s.html">bls_hmac_ripemd160_t</a> *&#160;</td>
          <td class="paramname"><em>hmac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a HMAC sha512 context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">hmac</td><td>the context to init. The context shall be in RAM</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>hmac key value Passing a NULL pointeur, will reinit the context with the previously set key. If no key has already been set, passing NULL will lead into an undefined behavior.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_len</td><td>hmac key length The key length shall be less than 64 bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error </dd></dl>

</div>
</div>
<a class="anchor" id="ab34272ffc5ce28f25c4cfb36aefe22fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_hmac_sha256_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__hmac__sha256__s.html">bls_hmac_sha256_t</a> *&#160;</td>
          <td class="paramname"><em>hmac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a HMAC sha256 context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">hmac</td><td>the context to init. The context shall be in RAM</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>hmac key value Passing a NULL pointeur, will reinit the context with the previously set key. If no key has already been set, passing NULL will lead into an undefined behavior.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_len</td><td>hmac key length The key length shall be less than 64 bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error </dd></dl>

</div>
</div>
<a class="anchor" id="ad3d34d342ab9ce56a456cbd0587d6d02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_hmac_sha512_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__hmac__sha512__s.html">bls_hmac_sha512_t</a> *&#160;</td>
          <td class="paramname"><em>hmac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a HMAC sha512 context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">hmac</td><td>the context to init. The context shall be in RAM</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>hmac key value Passing a NULL pointeur, will reinit the context with the previously set key. If no key has already been set, passing NULL will lead into an undefined behavior.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_len</td><td>hmac key length The key length shall be less than 128 bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error </dd></dl>

</div>
</div>
<a class="anchor" id="a0c80aaf95b68fb56584af500db272d63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_keccak_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__sha3__s.html">bls_sha3_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a Keccak (pre-release sha3) context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">hash</td><td>the context to init. The context shall be in RAM</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>output size, in bits (valid 224, 256, 384, 512)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error </dd></dl>

</div>
</div>
<a class="anchor" id="af7c0b25f3ac0307842bbdc9322d223c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bls_math_addm </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modular addition of tow big integer of the size: r = a+b mod m. </p>
<dl class="section warning"><dt>Warning</dt><dd>THIS METHOD IS NOT SUPPORTED IN THE CURRENT RELEASE</dd></dl>
<p>The maximum length supported is 64.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>where to put result </td></tr>
    <tr><td class="paramname">a</td><td>first operand </td></tr>
    <tr><td class="paramname">b</td><td>second operand </td></tr>
    <tr><td class="paramname">m</td><td>modulo </td></tr>
    <tr><td class="paramname">len</td><td>byte length of r, a, b, m </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4762eaf9596091725da4a10c29a9a11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_math_cmp </td>
          <td>(</td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare to unsigned long big-endian integer. </p>
<dl class="section warning"><dt>Warning</dt><dd>THIS METHOD IS NOT SUPPORTED IN THE CURRENT RELEASE</dd></dl>
<p>The maximum length supported is 64.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first operand </td></tr>
    <tr><td class="paramname">b</td><td>second operand </td></tr>
    <tr><td class="paramname">len</td><td>byte length of a, b</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if a==b, negative value if a&lt;b, positive value if a&gt;b </dd></dl>

</div>
</div>
<a class="anchor" id="a10b79f52eef59c6677690dc81151aeeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_math_is_zero </td>
          <td>(</td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare to unsigned long big-endian integer to zero. </p>
<dl class="section warning"><dt>Warning</dt><dd>THIS METHOD IS NOT SUPPORTED IN THE CURRENT RELEASE</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>value to compare to zero </td></tr>
    <tr><td class="paramname">len</td><td>byte length of a</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if a==0, 0 else </dd></dl>

</div>
</div>
<a class="anchor" id="a9a451e351994ca9009b5409b1d03af28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bls_math_modm </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len_m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce in place (left zero padded) the given value : v = v mod m. </p>
<dl class="section warning"><dt>Warning</dt><dd>THIS METHOD IS NOT SUPPORTED IN THE CURRENT RELEASE</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>value to reduce </td></tr>
    <tr><td class="paramname">len_v</td><td>shall be &gt;= len_m </td></tr>
    <tr><td class="paramname">m</td><td>modulus </td></tr>
    <tr><td class="paramname">len_m</td><td>length of modulus </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38d640ec48693b729dd31573b24ea52a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_pbkdf2 </td>
          <td>(</td>
          <td class="paramtype">bls_md_t&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbls__area__s.html">bls_area_t</a> *&#160;</td>
          <td class="paramname"><em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbls__area__s.html">bls_area_t</a> *&#160;</td>
          <td class="paramname"><em>salt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stretch a password using PBKDF2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>Hash Algorithm Supported algorithms : BLS_SHA512</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">password</td><td>Password buffer and length</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">salt</td><td>Salt buffer and length The salt buffer shall include 4 extra pdding bytes</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterations</td><td>Number of PBKDF2 iterations to perform</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Output buffer containing the PBKDF2 streched password The output buffer shall be as long as the hash output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error </dd></dl>

</div>
</div>
<a class="anchor" id="acba01fa194837c31b70ab42fea9c4f2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_ripemd160_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__ripemd160__s.html">bls_ripemd160_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a ripmd160 context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">hash</td><td>the context to init. The context shall be in RAM</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error </dd></dl>

</div>
</div>
<a class="anchor" id="abe4ef0ded59c23b0cd53552889762014"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_rng </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generate a random buffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>the buffer containing the random data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the random buffer to generate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error </dd></dl>

</div>
</div>
<a class="anchor" id="a9241faad72a37fea612c337a82e964aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t bls_rng_u8 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generate a random byte </p>
<dl class="section return"><dt>Returns</dt><dd>random byte </dd></dl>

</div>
</div>
<a class="anchor" id="a6a39bcc62951fe07ac5ddcb38f15758a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_rsa_generate_keypair </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>modulus_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbls__rsa__abstract__private__key__s.html">bls_rsa_abstract_private_key_t</a> *&#160;</td>
          <td class="paramname"><em>privateKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbls__rsa__abstract__public__key__s.html">bls_rsa_abstract_public_key_t</a> *&#160;</td>
          <td class="paramname"><em>publicKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbls__rsa__keypair__data__s.html">bls_rsa_keypair_data_t</a> *&#160;</td>
          <td class="paramname"><em>generatedKeypairInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a RSA keypair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">modulus_len</td><td>Length of the modulus to generate, in bits</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">privateKey</td><td>Pointer to a previously initialized RSA private key</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">publicKey</td><td>Pointer to a previously initialized RSA public key</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">generatedKeypairInfo</td><td>Pointer to a structure that will contain the generated key information including the private key value or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc949256aec16e18bb291e2668d8f693"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_rsa_get_public_key_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__rsa__abstract__public__key__s.html">bls_rsa_abstract_public_key_t</a> *&#160;</td>
          <td class="paramname"><em>publicKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbls__rsa__keypair__data__s.html">bls_rsa_keypair_data_t</a> *&#160;</td>
          <td class="paramname"><em>keyInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a RSA public key information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">publicKey</td><td>Pointer to a previously initialized RSA public key</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">keyInfo</td><td>Pointer to a structure that will contain the public key information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8df659201c372c4bb7d3df7d5fbc202a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_rsa_init_private_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbls__rsa__keypair__data__s.html">bls_rsa_keypair_data_t</a> WIDE *&#160;</td>
          <td class="paramname"><em>keyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbls__rsa__abstract__private__key__s.html">bls_rsa_abstract_private_key_t</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a private RSA Key. </p>
<p>Once initialized, the key may be stored in non-volatile memory an reused 'as-is' for any RSA processing Passing NULL as raw key initializes the key without value. The key can not be used</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyData</td><td>Key parameters value or NULL. Key parameters shall include the modulus and private exponent encoded as big endian raw value</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key</td><td>Private RSA key to initialize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acde738e372aa1e0bf6d157c4f0e292a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_rsa_init_private_key_crt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbls__rsa__crt__s.html">bls_rsa_crt_t</a> WIDE *&#160;</td>
          <td class="paramname"><em>crtParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbls__rsa__abstract__private__key__s.html">bls_rsa_abstract_private_key_t</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a private RSA Key with CRT parameters. </p>
<dl class="section warning"><dt>Warning</dt><dd>THIS METHOD IS NOT SUPPORTED IN THE CURRENT RELEASE</dd></dl>
<p>Once initialized, the key may be stored in non-volatile memory an reused 'as-is' for any RSA processing Passing NULL as raw key initializes the key without value. The key can not be used</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyData</td><td>Key parameters value or NULL. Key parameters shall include Q, P, DP, DQ, QInv encoded as big endian raw value</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key</td><td>Public RSA key to initialize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28fa77fc850d8e44a085002ce63a7a4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_rsa_init_public_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbls__rsa__keypair__data__s.html">bls_rsa_keypair_data_t</a> WIDE *&#160;</td>
          <td class="paramname"><em>keyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbls__rsa__abstract__public__key__s.html">bls_rsa_abstract_public_key_t</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a public RSA Key. </p>
<p>Once initialized, the key may be stored in non-volatile memory an reused 'as-is' for any RSA processing Passing NULL as raw key initializes the key without value. The key can not be used</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyData</td><td>Key parameters value or NULL. Key parameters shall include the modulus and public exponent encoded as big endian raw value</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key</td><td>Public RSA key to initialize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac62e06cad62c7a39b6a62015f3252ecd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_rsa_priv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__rsa__abstract__private__key__s.html">bls_rsa_abstract_private_key_t</a> WIDE *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bls_md_t&#160;</td>
          <td class="paramname"><em>hashID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbls__area__s.html">bls_area_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbls__area__s.html">bls_area_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a RSA private operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Pointer to a previously initialized RSA private key</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>16bits crypto mode flags. See above. Supported flags:<ul>
<li>BLS_LAST</li>
<li>BLS_ENCRYPT</li>
<li>BLS_DECRYPT</li>
<li>BLS_PAD_NONE</li>
<li>BLS_PAD_PKCS1_1o5</li>
<li>BLS_PAD_PSS</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hashID</td><td>Hash identifier used to compute the input data.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Input buffer and length to process</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dest</td><td>Destination buffer and length. Length is modified by ENCRYPT, DECRYPT, SIGN operations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>In case of ENCRYPT, DECRYPT or SIGN mode: 1 if success, 0 if error</li>
<li>In case of VERIFY mode: 0 if signature is false, 1 if signature is correct</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9dc43b301fc2f630af838d5164075bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_rsa_pub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__rsa__abstract__public__key__s.html">bls_rsa_abstract_public_key_t</a> WIDE *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bls_md_t&#160;</td>
          <td class="paramname"><em>hashID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbls__area__s.html">bls_area_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbls__area__s.html">bls_area_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a RSA public operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Pointer to a previously initialized RSA public key</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>16bits crypto mode flags. See above. Supported flags:<ul>
<li>BLS_LAST</li>
<li>BLS_ENCRYPT</li>
<li>BLS_DECRYPT</li>
<li>BLS_PAD_NONE</li>
<li>BLS_PAD_PKCS1_1o5</li>
<li>BLS_PAD_PSS</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hashID</td><td>Hash identifier used to compute the input data.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Input buffer and length to process</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dest</td><td>Destination buffer and length. Length is modified by ENCRYPT, DECRYPT, SIGN operations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>In case of ENCRYPT, DECRYPT or SIGN mode: 1 if success, 0 if error</li>
<li>In case of VERIFY mode: 0 if signature is false, 1 if signature is correct</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0650665b77deb5b79b48626649b33f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_schnorr_sign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__ecfp__private__key__s.html">bls_ecfp_private_key_t</a> WIDE *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bls_md_t&#160;</td>
          <td class="paramname"><em>hashID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hash_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sign a hash message according to Schnorr scheme. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>A private ecfp key fully inited with 'bls_ecdsa_init_private_key'</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>16bits crypto mode flags. See above. Supported flags:<ul>
<li>BLS_LAST</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hashID</td><td>Ignored</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>Input data to sign. The data should be the hash of the original message. The data length must be lesser than the curve size.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_len</td><td>Length of the hash</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sig</td><td>Schnorr signature</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Full length of signature</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1509989f1a3110ec245bc3cea7d0a9fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_schnorr_verify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__ecfp__public__key__s.html">bls_ecfp_public_key_t</a> WIDE *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bls_md_t&#160;</td>
          <td class="paramname"><em>hashID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t WIDE *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hash_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify a hash message signature according to Schnorr scheme. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>A public ecfp key fully inited with 'bls_ecdsa_init_public_key'</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>16bits crypto mode flags. See above. Supported flags:<ul>
<li>BLS_LAST</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hashID</td><td>Ignored</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>Signed input data to verify the signature. The data should be the hash of the original message. The data length must be lesser than the curve size.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_len</td><td>Length of the hash</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>Schnorr signature</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if signature is verified 0 is signarure is not verified</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">INVALID_PARAMETER</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11e0ea766e9c8e6dc2872b6098af76c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_sha1_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__sha1__s.html">bls_sha1_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a sha1 context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">hash</td><td>the context to init. The context shall be in RAM</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error </dd></dl>

</div>
</div>
<a class="anchor" id="acae228da69e446f7093ce2da0cee7d2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_sha256_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__sha256__s.html">bls_sha256_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a sha256 context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">hash</td><td>the context to init. The context shall be in RAM</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error </dd></dl>

</div>
</div>
<a class="anchor" id="a1d45b76b36a4a8a8e439e06cb9bf38bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_sha3_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__sha3__s.html">bls_sha3_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a sha3 context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">hash</td><td>the context to init. The context shall be in RAM</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>output size, in bits (valid 224, 256, 384, 512)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error </dd></dl>

</div>
</div>
<a class="anchor" id="ab139b1d61cdb1e045e7647f34808f155"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bls_sha512_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbls__sha512__s.html">bls_sha512_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a sha512 context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">hash</td><td>the context to init. The context shall be in RAM</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if success, 0 if error </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
