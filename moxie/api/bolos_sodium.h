/*
*******************************************************************************
*   BOLOS TEE
*   (c) 2016, 2017 Ledger
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
*   Unless required by applicable law or agreed to in writing, software
*   distributed under the License is distributed on an "AS IS" BASIS,
*   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*   limitations under the License.
********************************************************************************/

/*
 * libsodium Copyright (c) 2013-2017
 * Frank Denis <j at pureftpd dot org>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/**
 * @brief Limited libsodium/NaCl implementation
 * @file bolos_sodium.h
 * @author Ledger Firmware Team <hello@ledger.fr>
 * @version 1.0
 * @date 29th of February 2016
 *
 * Provide an interface to the box, secretbox, auth, and signature on ED25519
 * APIs from libsodium / NaCl
 *
 * This API is specific to the TEE implementation. Support on other platforms is
 * being added.
 */

#ifndef __BOLOS_SODIUM_H__

#define __BOLOS_SODIUM_H__

#define crypto_secretbox_MACBYTES 16
#define crypto_secretbox_NONCEBYTES 24
#define crypto_secretbox_KEYBYTES 32
#define crypto_auth_KEYBYTES 32
#define crypto_auth_BYTES 32
#define crypto_box_PUBLICKEYBYTES 32
#define crypto_box_SECRETKEYBYTES 32
#define crypto_box_NONCEBYTES 24
#define crypto_box_MACBYTES 16
#define crypto_box_SEALBYTES (crypto_box_PUBLICKEYBYTES + crypto_box_MACBYTES)
#define crypto_sign_PUBLICKEYBYTES 32
#define crypto_sign_SECRETKEYBYTES 64
#define crypto_sign_BYTES 64

/**
 * @brief Authenticated Encryption (XSalsa20 + Poly1305) of a message using a
 * symmetric key
 *
 * @param [out] c
 *   Destination buffer, should be at least crypto_secretbox_MACBYTES + mlen
 * bytes long
 *
 * @param [in] m
 *   Source buffer
 *
 * @param [in] mlen
 *   Size of the message to process
 *
 * @param [in] n
 *   Nonce, should be crypto_secretbox_NONCEBYTES bytes long
 *
 * @param [in] k
 *   Symmetric key, should be crypto_secretbox_KEYBYTES bytes long
 *
 * @return 0 if success, different value if error
 *
 */
int crypto_secretbox_easy(unsigned char *c, const unsigned char *m,
                          unsigned long mlen, const unsigned char *n,
                          const unsigned char *k);

/**
 * @brief Decrypt a message encrypted by crypto_secretbox_easy
 *
 * @param [out] m
 *   Destination buffer, should be at least clen - crypto_secretbox_MACBYTES
 * bytes long
 *
 * @param [in] c
 *   Source buffer
 *
 * @param [in] clen
 *   Size of the encrypted message to process
 *
 * @param [in] n
 *   Nonce used for crypto_secretbox_easy
 *
 * @param [in] k
 *   Symmetric key used for crypto_secretbox_easy
 *
 * @return 0 if success, different value if error
 *
 */
int crypto_secretbox_open_easy(unsigned char *m, const unsigned char *c,
                               unsigned long clen, const unsigned char *n,
                               const unsigned char *k);

/**
 * @brief Compute an authentication (HMAC) of a message using a symmetric key
 *
 * @param [out] out
 *   Destination buffer, should be at least crypto_auth_BYTES bytes long
 *
 * @param [in] in
 *   Source buffer
 *
 * @param [in] inlen
 *   Size of the message to process
 *
 * @param [in] k
 *   Symmetric key, should be crypto_auth_KEYBYTES bytes long
 *
 * @return 0 if success, different value if error
 *
 */
int crypto_auth(unsigned char *out, const unsigned char *in,
                unsigned long inlen, const unsigned char *k);

/**
 * @brief Verify an authentication (HMAC) of a message generated by crypto_auth
 *
 * @param [in] h
 *   Buffer containing the tag returned by crypto_auth
 *
 * @param [in] in
 *   Source buffer
 *
 * @param [in] inlen
 *   Size of the message to process
 *
 * @param [in] k
 *   Symmetric key used for crypto_auth
 *
 * @return 0 if success, different value if error
 *
 */
int crypto_auth_verify(const unsigned char *h, const unsigned char *in,
                       unsigned long inlen, const unsigned char *k);

/**
 * @brief Generate a keypair to be used for Authenticated Encryption with
 * crypto_box functions
 *
 * @param [out] pk
 *   Destination buffer for the public key, should be at least
 * crypto_box_PUBLICKEYBYTES bytes long
 *
 * @param [out] sk
 *   Destination buffer for the private key, should be at least
 * crypto_box_SECRETKEYBYTES bytes long
 *
 * @return 0 if success, different value if error
 *
 */
int crypto_box_keypair(unsigned char *pk, unsigned char *sk);

/**
 * @brief Authenticated Encryption (X25519 + XSalsa20 + Poly1305) of a message
 * using an asymmetric keypair
 *
 * @param [out] c
 *   Destination buffer, should be at least crypto_box_SEALBYTES + mlen bytes
 * long
 *
 * @param [in] m
 *   Source buffer
 *
 * @param [in] mlen
 *   Size of the message to process
 *
 * @param [in] n
 *   Nonce, should be crypto_box_NONCEBYTES bytes long
 *
 * @param [in] pk
 *   Public key of the recipient generated previously
 *
 * @param [in] sk
 *   Private key of the sender generated previously
 *
 * @return 0 if success, different value if error
 *
 */
int crypto_box_easy(unsigned char *c, const unsigned char *m,
                    unsigned long mlen, const unsigned char *n,
                    const unsigned char *pk, const unsigned char *sk);

/**
 * @brief Decrypt a message encrypted by crypto_box_easy
 *
 * @param [out] m
 *   Destination buffer, should be at least clen - crypto_box_MACBYTES bytes
 * long
 *
 * @param [in] c
 *   Source buffer
 *
 * @param [in] clen
 *   Size of the encrypted message to process
 *
 * @param [in] n
 *   Nonce used for crypto_box_easy
 *
 * @param [in] pk
 *   Public key of the sender generated previously
 *
 * @param [in] sk
 *   Private key of the recipient generated previously
 *
 * @return 0 if success, different value if error
 *
 */
int crypto_box_open_easy(unsigned char *m, const unsigned char *c,
                         unsigned long clen, const unsigned char *n,
                         const unsigned char *pk, const unsigned char *sk);

/**
 * @brief Anonymous encryption (X25519, XSalsa20, Poly1305) of a message using
 * an asymmetric keypair
 *
 * @param [out] c
 *   Destination buffer, should be at least crypto_box_SEALBYTES + mlen bytes
 * long
 *
 * @param [in] m
 *   Source buffer
 *
 * @param [in] mlen
 *   Size of the message to process
 *
 * @param [in] pk
 *   Public key of the recipient generated previously
 *
 * @return 0 if success, different value if error
 *
 */
int crypto_box_seal(unsigned char *c, const unsigned char *m,
                    unsigned long mlen, const unsigned char *pk);

/**
 * @brief Decrypt a message encrypted by crypto_box_seal
 *
 * @param [out] m
 *   Destination buffer, should be at least clen - crypto_box_SEALBYTES bytes
 * long
 *
 * @param [in] c
 *   Source buffer
 *
 * @param [in] clen
 *   Size of the encrypted message to process
 *
 * @param [in] pk
 *   Public key of the recipient generated previously
 *
 * @param [in] sk
 *   Private key of the recipient generated previously
 *
 * @return 0 if success, different value if error
 *
 */
int crypto_box_seal_open(unsigned char *m, const unsigned char *c,
                         unsigned long clen, const unsigned char *pk,
                         const unsigned char *sk);

/**
 * @brief Generate a keypair to be used for Signature with crypto_sign functions
 *
 * @param [out] pk
 *   Destination buffer for the public key, should be at least
 * crypto_sign_PUBLICKEYBYTES bytes long
 *
 * @param [out] sk
 *   Destination buffer for the private key, should be at least
 * crypto_sign_SECRETKEYBYTES bytes long
 *
 * @return 0 if success, different value if error
 *
 */
int crypto_sign_keypair(unsigned char *pk, unsigned char *sk);

/**
 * @brief Generate a Combined Signature (Ed25519) of a message using an
 * asymmetric keypair
 *
 * @param [out] sm
 *   Destination buffer, should be at least crypto_sign_BYTES + mlen bytes long
 *
 * @param [in,out] smlem_p
 *   Pointer to the length of the destination buffer, filled with the actual
 * length of the result
 *
 * @param [in] m
 *   Source buffer
 *
 * @param [in] mlen
 *   Size of the message to process
 *
 * @param [in] sk
 *   Private key of the sender generated previously
 *
 * @return 0 if success, different value if error
 *
 */
int crypto_sign(unsigned char *sm, unsigned long *smlen_p,
                const unsigned char *m, unsigned long mlen,
                const unsigned char *sk);

/**
 * @brief Unwrap a message wrapped by crypto_sign
 *
 * @param [out] m
 *   Destination buffer, should be at least smlen bytes long
 *
 * @param [in,out] mlem_p
 *   Pointer to the length of the destination buffer, filled with the actual
 * length of the result
 *
 * @param [in] sm
 *   Source buffer
 *
 * @param [in] smlen
 *   Size of the message to process
 *
 * @param [in] pk
 *   Public key of the sender generated previously
 *
 * @return 0 if success, different value if error
 *
 */
int crypto_sign_open(unsigned char *m, unsigned long *mlen_p,
                     const unsigned char *sm, unsigned long smlen,
                     const unsigned char *pk);

#endif //__BOLOS_SODIUM_H__
